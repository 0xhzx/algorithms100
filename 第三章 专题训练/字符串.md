# 字符串
字符串很直白常用，然而算法常常比一个字符串长的多。

## 设计一个字符串查找函数
朴素算法，以当前字符为尾字符，逐字符比较。
模式串“abaabcac”中，若第一个c不配，模式串指针不止移动一位，而是移动到开头aba的末尾a中。因为之前的ab已经比较过了且适配，模式串本身蕴含了确定性信息，怎么利用上呢？
KMP算法加速了不配状态，不配的移动距离即当前的公共前缀长。

## 编辑距离
编辑一次只可以增删改一个字符，从串s到串t，需要经过多少次编辑？
亦是动态规划，dp[i]到dp[j]需要编辑多少次，等于之前编辑次数和当前字符是否相等。

## 最长回文子串
除了遍历外，还有马拉车算法。
[  [ A ]  M  [ B ]  ],若M为中心的一个大回文串，包含A小回文串，则对称位置B亦是回文串。算法复杂度O(n)。

## 字典树
查询一个单词是否在一个字典中
将词汇表合并成一棵前缀树

## AC自动机
要在长文本中查找多个模式串

多个模式串可以构建前缀树，若不配，不需要回退到根节点，只是不能适配当前模式串，可以转移到其他模式串中。这个失败指针就是逐次向父节点遍历，看是否有共同的子字符，说明此之上的链条是适配过的公共前缀。单个节点最坏情形下向上搜寻需要logn，但一边认为总体平均复杂度是n。
AC自动机也可以用双队列存储。

## 后缀自动机
要查到字符串有多少字串，构建出前缀树，则枝叶很多是相同的，后缀自动机将相同后缀合并。
先看图示
后缀自动机构建节点x，需要step[x]表示从根节点走到x的长度；pre
[x]是不配指针，仅在构建自动机中使用，x节点的后缀也是pre[x]的后缀；
right[x]是以x为末尾的子串集合，
https://csgblog.top/4ccf99cf81c42233c714e9064d32a457/%E6%B5%85%E8%B0%88%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%EF%BC%9A%E6%A6%82%E8%BF%B0%EF%BC%8C%E6%9E%84%E5%BB%BA%E4%B8%8E%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/
https://blog.csdn.net/clover_hxy/article/details/53758535
https://www.mina.moe/archives/3322

## 设计一个正则查找函数，包括*?
？表示出现0~1次，*表示任意出现次